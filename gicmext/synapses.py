#!/usr/bin/env python
# encoding: utf-8
#Created by Graham Cummins on 2007-07-18.

# Copyright (C) 2007 Graham I Cummins
# This program is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation; either version 2 of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
# PARTICULAR PURPOSE. See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along with
# this program; if not, write to the Free Software Foundation, Inc., 59 Temple
# Place, Suite 330, Boston, MA 02111-1307 USA
#

from mien.interface.modelbuilder import SYNPROP
from numpy import *

def getSynInfo(ds, upath):
	'''upath should be the upath of a SynapticEvents element. This function constructs an array with columns specifying [Label, Direction, Length, Latency, Cercus] for each synapse in that group. Cercus is represented using 0 for left and 1 for right. That array is set as the data content of ds. The upath is stored in the new attribute "SynapticEvents" of ds'''
	se=ds.getInstance(upath)
	ds.setAttrib('SynapticEvents', upath)
	syns=se.synapses()
	a=zeros((len(syns),5), float32)
	for ind, i in enumerate(syns.keys()):
		a[ind,0]=i
		s=syns[i][0]
		a[ind,1]=s.attrib('Direction')
		a[ind,2]=s.attrib('Length')
		a[ind,3]=s.attrib('Latency')
		if 'R' in s.attrib('Cercus'):
			a[ind,4]=1
	ds.datinit(a, {'SampleType':'table'})

def _refract(evts, refract):
	ne=[evts[0]]
	for et in evts[1:]:
		if et-ne[-1]>=refract:
			ne.append(et)
	return array(ne)
	
def blockStim(ds, time=.002, duration=.005, power=1.0, direction=315, refract=.001, latencyscale=1.0):
	'''A simplified stimulus generator. This function expects an input ds of the type generated by getSynInfo. The output ds is labeledevents, and containing event times for each unit.  Events are computed using probability of event in a .1 ms time bin = power*cos(direction - synapse direction) from time to time+duration and 0 otherwise. Events are restricted to not occur at intervals shorter than refract. Events are delayed by the Latency value of each synapse (which is in milliseconds, unlike time, duration, and refract which are in seconds).'''
	events=zeros((0,2))
	fs=10000
	npts=int(round(duration*fs))
	refpts=int(round(refract*fs))
	dat=ds.getData()
	for ind in range(dat.shape[0]):
		lab=dat[ind,0]
		thresh=power*cos( (direction-dat[ind, 1])*pi/180.0 )
		evts=nonzero(random.uniform(0,1,npts)<=thresh)[0]
		if evts.shape[0]>0:
			evts=_refract(evts, refpts)
			lat=4.0+(dat[ind,3]-4.0)*latencyscale
			lat=int(round(lat*fs/1000.0))
			evts+=lat
			evts=column_stack([evts, ones_like(evts)*lab])
			events=row_stack([events, evts])
	head={'SampleType':'labeledevents', 'SamplesPerSecond':fs, 'StartTime':time}
	ds.datinit(events, head)

def returnEvents(ds):
	'''If the attribute SynapticEvents is defined, this function writes the data in ds into the event data set for the SynapticEvent element'''
	se=ds.attrib('SynapticEvents')
	se=ds.getInstance(se)
	se.findDataElement()
	se.data.mirror(ds)